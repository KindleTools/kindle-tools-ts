/**
 * Plugin hooks system.
 *
 * Provides lifecycle hooks that plugins can use to intercept and transform
 * data during import/export operations.
 *
 * ## Available Hooks
 *
 * - `beforeImport`: Called before parsing input, can transform raw content
 * - `afterImport`: Called after parsing, can transform/filter clippings
 * - `beforeExport`: Called before export, can transform/filter clippings
 * - `afterExport`: Called after export, can transform output
 *
 * @example
 * ```typescript
 * import { hookRegistry } from 'kindle-tools-ts/plugins';
 *
 * // Add a hook to filter out short highlights
 * hookRegistry.add('beforeExport', (clippings) => {
 *   return clippings.filter(c => (c.content?.length ?? 0) > 20);
 * });
 *
 * // Add a hook to add a watermark to exports
 * hookRegistry.add('afterExport', (output) => {
 *   return `// Generated by KindleTools\n${output}`;
 * });
 * ```
 *
 * @packageDocumentation
 */

import type { Clipping } from "#app-types/clipping.js";

// =============================================================================
// Hook Types
// =============================================================================

/**
 * Hook that runs before importing (transforms raw content).
 */
export type BeforeImportHook = (content: string) => string | Promise<string>;

/**
 * Hook that runs after importing (transforms parsed clippings).
 */
export type AfterImportHook = (clippings: Clipping[]) => Clipping[] | Promise<Clipping[]>;

/**
 * Hook that runs before exporting (transforms clippings).
 */
export type BeforeExportHook = (
  clippings: Clipping[],
  format: string,
) => Clipping[] | Promise<Clipping[]>;

/**
 * Hook that runs after exporting (transforms output).
 */
export type AfterExportHook = (output: string, format: string) => string | Promise<string>;

/**
 * All hook types.
 */
export type HookType = "beforeImport" | "afterImport" | "beforeExport" | "afterExport";

/**
 * Hook function by type.
 */
export type HookFunction<T extends HookType> = T extends "beforeImport"
  ? BeforeImportHook
  : T extends "afterImport"
    ? AfterImportHook
    : T extends "beforeExport"
      ? BeforeExportHook
      : T extends "afterExport"
        ? AfterExportHook
        : never;

// =============================================================================
// Hook Registry
// =============================================================================

/**
 * Registry for managing plugin hooks.
 *
 * Hooks are executed in the order they were registered.
 */
class HookRegistry {
  private readonly hooks: {
    beforeImport: BeforeImportHook[];
    afterImport: AfterImportHook[];
    beforeExport: BeforeExportHook[];
    afterExport: AfterExportHook[];
  } = {
    beforeImport: [],
    afterImport: [],
    beforeExport: [],
    afterExport: [],
  };

  /**
   * Register a hook.
   *
   * @param type - Hook type
   * @param hook - Hook function
   * @returns Unregister function
   */
  add<T extends HookType>(type: T, hook: HookFunction<T>): () => void {
    const hookArray = this.hooks[type];
    hookArray.push(hook as never);

    // Return unregister function
    return () => {
      const index = hookArray.indexOf(hook as never);
      if (index !== -1) {
        hookArray.splice(index, 1);
      }
    };
  }

  /**
   * Run all hooks of a type.
   */
  async runBeforeImport(content: string): Promise<string> {
    let result = content;
    for (const hook of this.hooks.beforeImport) {
      result = await hook(result);
    }
    return result;
  }

  /**
   * Run afterImport hooks.
   */
  async runAfterImport(clippings: Clipping[]): Promise<Clipping[]> {
    let result = clippings;
    for (const hook of this.hooks.afterImport) {
      result = await hook(result);
    }
    return result;
  }

  /**
   * Run beforeExport hooks.
   */
  async runBeforeExport(clippings: Clipping[], format: string): Promise<Clipping[]> {
    let result = clippings;
    for (const hook of this.hooks.beforeExport) {
      result = await hook(result, format);
    }
    return result;
  }

  /**
   * Run afterExport hooks.
   */
  async runAfterExport(output: string, format: string): Promise<string> {
    let result = output;
    for (const hook of this.hooks.afterExport) {
      result = await hook(result, format);
    }
    return result;
  }

  /**
   * Check if any hooks are registered for a type.
   */
  hasHooks(type: HookType): boolean {
    return this.hooks[type].length > 0;
  }

  /**
   * Get count of registered hooks.
   */
  getHookCount(): Record<HookType, number> {
    return {
      beforeImport: this.hooks.beforeImport.length,
      afterImport: this.hooks.afterImport.length,
      beforeExport: this.hooks.beforeExport.length,
      afterExport: this.hooks.afterExport.length,
    };
  }

  /**
   * Clear all hooks.
   */
  clear(): void {
    this.hooks.beforeImport.length = 0;
    this.hooks.afterImport.length = 0;
    this.hooks.beforeExport.length = 0;
    this.hooks.afterExport.length = 0;
  }

  /**
   * Clear hooks of a specific type.
   */
  clearType(type: HookType): void {
    this.hooks[type].length = 0;
  }
}

// =============================================================================
// Singleton Export
// =============================================================================

/**
 * Global hook registry instance.
 */
export const hookRegistry = new HookRegistry();

// Export class for testing or custom instances
export { HookRegistry };

// =============================================================================
// Utility Hooks
// =============================================================================

/**
 * Create a hook that filters clippings by minimum content length.
 */
export function createMinLengthFilter(minLength: number): BeforeExportHook {
  return (clippings) => clippings.filter((c) => (c.content?.length ?? 0) >= minLength);
}

/**
 * Create a hook that filters to only highlights.
 */
export function createHighlightsOnlyFilter(): BeforeExportHook {
  return (clippings) => clippings.filter((c) => c.type === "highlight");
}

/**
 * Create a hook that adds a header comment to output.
 */
export function createHeaderHook(header: string): AfterExportHook {
  return (output) => `${header}\n${output}`;
}

/**
 * Create a hook that adds a timestamp to output.
 */
export function createTimestampHook(): AfterExportHook {
  return (output, format) => {
    const timestamp = new Date().toISOString();
    const comment = format === "json" ? "" : `// Generated: ${timestamp}\n`;
    return `${comment}${output}`;
  };
}
